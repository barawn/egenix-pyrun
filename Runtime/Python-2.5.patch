--- Modules/getpath.c.orig	2012-04-23 00:57:29.779087102 +0200
+++ Modules/getpath.c	2012-04-23 00:57:37.979086891 +0200
@@ -444,10 +444,21 @@ calculate_path(void)
 	if (progpath[0] != SEP)
 		absolutize(progpath);
 	strncpy(argv0_path, progpath, MAXPATHLEN);
 	argv0_path[MAXPATHLEN] = '\0';
 
+    /* For PyRun we don't need all the machinery to setup sys.path, since
+       we're doing that in pyrun.py, so just use some sane defaults and
+       return. */
+    if (Py_FrozenFlag) {
+	strncpy(prefix, PREFIX, MAXPATHLEN);
+	strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
+	module_search_path = (char *)PyMem_Malloc(MAXPATHLEN);
+	strncpy(module_search_path, PREFIX "/lib/python" VERSION, MAXPATHLEN);
+	return;
+    }
+
 #ifdef WITH_NEXT_FRAMEWORK
 	/* On Mac OS X we have a special case if we're running from a framework.
 	** This is because the python home should be set relative to the library,
 	** which is in the framework, not relative to the executable, which may
 	** be outside of the framework. Except when we're in the build directory...
--- Python/import.c.orig	2007-08-23 20:08:33.000000000 +0200
+++ Python/import.c	2012-09-24 20:56:54.293351338 +0200
@@ -1186,49 +1186,30 @@ find_module(char *fullname, char *subnam
 			Py_DECREF(loader);
 		}
 		Py_DECREF(meta_path);
 	}
 
-	if (path != NULL && PyString_Check(path)) {
-		/* The only type of submodule allowed inside a "frozen"
-		   package are other frozen modules or packages. */
-		if (PyString_Size(path) + 1 + strlen(name) >= (size_t)buflen) {
-			PyErr_SetString(PyExc_ImportError,
-					"full frozen module name too long");
-			return NULL;
-		}
-		strcpy(buf, PyString_AsString(path));
-		strcat(buf, ".");
-		strcat(buf, name);
-		strcpy(name, buf);
-		if (find_frozen(name) != NULL) {
-			strcpy(buf, name);
-			return &fd_frozen;
-		}
-		PyErr_Format(PyExc_ImportError,
-			     "No frozen submodule named %.200s", name);
-		return NULL;
+	if (find_frozen(fullname) != NULL) {
+	    strcpy(buf, fullname);
+	    return &fd_frozen;
 	}
+
 	if (path == NULL) {
 		if (is_builtin(name)) {
 			strcpy(buf, name);
 			return &fd_builtin;
 		}
-		if ((find_frozen(name)) != NULL) {
-			strcpy(buf, name);
-			return &fd_frozen;
-		}
-
 #ifdef MS_COREDLL
 		fp = PyWin_FindRegisteredModule(name, &fdp, buf, buflen);
 		if (fp != NULL) {
 			*p_fp = fp;
 			return fdp;
 		}
 #endif
 		path = PySys_GetObject("path");
 	}
+
 	if (path == NULL || !PyList_Check(path)) {
 		PyErr_SetString(PyExc_ImportError,
 				"sys.path must be a list of directory names");
 		return NULL;
 	}
@@ -1856,10 +1837,13 @@ init_builtin(char *name)
 static struct _frozen *
 find_frozen(char *name)
 {
 	struct _frozen *p;
 
+	if (!name)
+	    return NULL;
+
 	for (p = PyImport_FrozenModules; ; p++) {
 		if (p->name == NULL)
 			return NULL;
 		if (strcmp(p->name, name) == 0)
 			break;
@@ -1929,21 +1913,27 @@ PyImport_ImportFrozenModule(char *name)
 			     name);
 		goto err_return;
 	}
 	if (ispackage) {
 		/* Set __path__ to the package name */
-		PyObject *d, *s;
+	    PyObject *d, *s, *l;
 		int err;
 		m = PyImport_AddModule(name);
 		if (m == NULL)
 			goto err_return;
 		d = PyModule_GetDict(m);
 		s = PyString_InternFromString(name);
 		if (s == NULL)
-			goto err_return;
-		err = PyDict_SetItemString(d, "__path__", s);
-		Py_DECREF(s);
+		    goto err_return;
+		l = PyList_New(1);
+		if (l == NULL) {
+		    Py_DECREF(s);
+		    goto err_return;
+		}
+		PyList_SET_ITEM(l, 0, s);
+		err = PyDict_SetItemString(d, "__path__", l);
+		Py_DECREF(l);
 		if (err != 0)
 			goto err_return;
 	}
 	m = PyImport_ExecCodeModuleEx(name, co, "<frozen>");
 	if (m == NULL)
