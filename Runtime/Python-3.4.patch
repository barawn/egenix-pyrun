diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-3.4.1/Lib/importlib/_bootstrap.py ./Lib/importlib/_bootstrap.py
--- /home/lemburg/egenix/projects/PyRun/Python-3.4.1/Lib/importlib/_bootstrap.py	2014-05-19 07:19:38.000000000 +0200
+++ ./Lib/importlib/_bootstrap.py	2014-06-12 02:10:37.486673987 +0200
@@ -1356,6 +1356,7 @@
             raise ImportError('{!r} is not a frozen module'.format(name),
                               name=name)
         code = _call_with_frames_removed(_imp.get_frozen_object, name)
+        module.__file__ = code.co_filename
         exec(code, module.__dict__)
 
     @classmethod
diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-3.4.1/Lib/lib2to3/pgen2/driver.py ./Lib/lib2to3/pgen2/driver.py
--- /home/lemburg/egenix/projects/PyRun/Python-3.4.1/Lib/lib2to3/pgen2/driver.py	2014-05-19 07:19:38.000000000 +0200
+++ ./Lib/lib2to3/pgen2/driver.py	2014-06-12 02:18:40.239001169 +0200
@@ -111,6 +111,14 @@
     """Load the grammar (maybe from a pickle)."""
     if logger is None:
         logger = logging.getLogger()
+    # eGenix PyRun support using pyrun_grammar.py to avoid having to
+    # carry around the grammar files
+    if gt == '<pyrun>/lib2to3/Grammar.txt':
+        import pyrun_grammar
+        return pyrun_grammar.load_python_grammar()
+    elif gt == '<pyrun>/lib2to3/PatternGrammar.txt':
+        import pyrun_grammar
+        return pyrun_grammar.load_pattern_grammar()
     if gp is None:
         head, tail = os.path.splitext(gt)
         if tail == ".txt":
diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-3.4.1/Modules/getpath.c ./Modules/getpath.c
--- /home/lemburg/egenix/projects/PyRun/Python-3.4.1/Modules/getpath.c	2014-05-19 07:19:39.000000000 +0200
+++ ./Modules/getpath.c	2014-06-12 00:54:26.929428034 +0200
@@ -566,6 +566,24 @@
     wcsncpy(argv0_path, progpath, MAXPATHLEN);
     argv0_path[MAXPATHLEN] = '\0';
 
+    /* For PyRun we don't need all the machinery to setup sys.path, since
+       we're doing that in pyrun.py, so just use some sane defaults and
+       return. */
+    if (Py_FrozenFlag) {
+	wcsncpy(prefix, _prefix, MAXPATHLEN);
+	wcsncpy(exec_prefix, _exec_prefix, MAXPATHLEN);
+	module_search_path = (wchar_t *)PyMem_Malloc(
+	    (MAXPATHLEN + 1) * sizeof(wchar_t));
+	if (!module_search_path) {
+	    Py_FatalError(
+		"Unable to setup sys.path in getpath.c: "
+		"memory error");
+	}
+	wcsncpy(module_search_path, _prefix, MAXPATHLEN);
+	joinpath(module_search_path, lib_python);
+	goto finish;
+    }
+
 #ifdef WITH_NEXT_FRAMEWORK
     /* On Mac OS X we have a special case if we're running from a framework.
     ** This is because the python home should be set relative to the library,
@@ -811,6 +829,7 @@
     else
         wcsncpy(exec_prefix, _exec_prefix, MAXPATHLEN);
 
+  finish:
     PyMem_RawFree(_pythonpath);
     PyMem_RawFree(_prefix);
     PyMem_RawFree(_exec_prefix);
diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-3.4.1/Python/import.c ./Python/import.c
--- /home/lemburg/egenix/projects/PyRun/Python-3.4.1/Python/import.c	2014-05-19 07:19:40.000000000 +0200
+++ ./Python/import.c	2014-06-12 02:12:33.739715917 +0200
@@ -1268,6 +1268,23 @@
     if (d == NULL) {
         goto err_return;
     }
+
+    /* Remember the filename as the __file__ attribute, for all frozen modules
+       except the special _frozen_importlib one (doing this breaks
+       bootstrapping for some reason)
+
+       Note: this function is only called during startup of the interpreter
+       and by C extensions. All other imports of frozen modules are handled by
+       the importlib. See importlib._bootstrap.FrozenImporter for details.
+
+    */
+    if (PyUnicode_CompareWithASCIIString(name, "_frozen_importlib") != 0) {
+	if (PyDict_SetItemString(d,
+				 "__file__",
+				 ((PyCodeObject *)co)->co_filename))
+	    PyErr_Clear(); /* Not important enough to report */
+    }
+
     m = exec_code_in_module(name, d, co);
     if (m == NULL)
         goto err_return;
diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-3.4.1/Python/sysmodule.c ./Python/sysmodule.c
--- /home/lemburg/egenix/projects/PyRun/Python-3.4.1/Python/sysmodule.c	2014-05-19 07:19:40.000000000 +0200
+++ ./Python/sysmodule.c	2014-06-12 00:54:26.929428034 +0200
@@ -1109,6 +1109,49 @@
 Clear the internal type lookup cache.");
 
 
+/*** PyRun Extension ***************************************************/
+
+#define SYS_SETFLAG(c_flag, flag_name)		\
+    if (strcmp(flagname, flag_name) == 0) {	\
+	old_value = c_flag;			\
+	if (value != -1)			\
+	    c_flag = value;			\
+    } else
+
+static PyObject *
+sys_setflag(PyObject* self, PyObject* args)
+{
+    char *flagname;
+    int value = -1, old_value = value;
+
+    if (!PyArg_ParseTuple(args, "s|i", &flagname, &value))
+        goto onError;
+
+    SYS_SETFLAG(Py_DebugFlag, "debug")
+    SYS_SETFLAG(Py_OptimizeFlag, "optimize")
+    SYS_SETFLAG(Py_DontWriteBytecodeFlag, "dont_write_bytecode")
+    SYS_SETFLAG(Py_VerboseFlag, "verbose")
+    SYS_SETFLAG(Py_HashRandomizationFlag, "hash_randomization")
+    {
+        PyErr_SetString(PyExc_ValueError,
+                        "unknown flag name");
+	goto onError;
+    }
+    return PyLong_FromLong((long)old_value);
+
+ onError:
+    return NULL;
+}
+
+#undef SYS_SETFLAG
+
+PyDoc_STRVAR(sys_setflag__doc__,
+"_setflag(flagname, value) -> old_value\n\
+Set the given interpreter flag and return its previous value.");
+
+/*** End of PyRun Extension ***********************************************/
+
+
 static PyMethodDef sys_methods[] = {
     /* Might as well keep this in alphabetic order */
     {"callstats", (PyCFunction)PyEval_GetCallStats, METH_NOARGS,
@@ -1171,6 +1214,7 @@
     {"setdlopenflags", sys_setdlopenflags, METH_VARARGS,
      setdlopenflags_doc},
 #endif
+    {"_setflag", sys_setflag, METH_VARARGS, sys_setflag__doc__},
     {"setprofile",      sys_setprofile, METH_O, setprofile_doc},
     {"getprofile",      sys_getprofile, METH_NOARGS, getprofile_doc},
     {"setrecursionlimit", sys_setrecursionlimit, METH_VARARGS,
