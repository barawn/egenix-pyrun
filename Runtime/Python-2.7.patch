diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Lib/lib2to3/pgen2/driver.py ./Lib/lib2to3/pgen2/driver.py
--- /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Lib/lib2to3/pgen2/driver.py	2014-12-10 16:59:38.000000000 +0100
+++ ./Lib/lib2to3/pgen2/driver.py	2015-04-21 15:44:02.530714258 +0200
@@ -111,6 +111,14 @@
     """Load the grammar (maybe from a pickle)."""
     if logger is None:
         logger = logging.getLogger()
+    # eGenix PyRun support using pyrun_grammar.py to avoid having to
+    # carry around the grammar files
+    if gt == '<pyrun>/lib2to3/Grammar.txt':
+        import pyrun_grammar
+        return pyrun_grammar.load_python_grammar()
+    elif gt == '<pyrun>/lib2to3/PatternGrammar.txt':
+        import pyrun_grammar
+        return pyrun_grammar.load_pattern_grammar()
     if gp is None:
         head, tail = os.path.splitext(gt)
         if tail == ".txt":
diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Lib/lib2to3/refactor.py ./Lib/lib2to3/refactor.py
--- /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Lib/lib2to3/refactor.py	2014-12-10 16:59:38.000000000 +0100
+++ ./Lib/lib2to3/refactor.py	2015-04-21 15:44:02.530714258 +0200
@@ -32,6 +32,16 @@
 
 def get_all_fix_names(fixer_pkg, remove_prefix=True):
     """Return a sorted list of all available fix names in the given package."""
+
+    # For eGenix PyRun we read the list from the config module
+    if __file__.startswith('<pyrun>') and fixer_pkg == 'lib2to3.fixes':
+        import pyrun_config
+        if remove_prefix:
+            return pyrun_config.lib2to3_fixes
+        else:
+            return ['fix_%s' % name
+                    for name in pyrun_config.lib2to3_fixes]
+
     pkg = __import__(fixer_pkg, [], [], ["*"])
     fixer_dir = os.path.dirname(pkg.__file__)
     fix_names = []
diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Lib/pkgutil.py ./Lib/pkgutil.py
--- /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Lib/pkgutil.py	2014-12-10 16:59:39.000000000 +0100
+++ ./Lib/pkgutil.py	2015-04-21 15:44:02.530714258 +0200
@@ -275,20 +275,27 @@
         return self.etc[2]==imp.PKG_DIRECTORY
 
     def get_code(self, fullname=None):
+        # eGenix PyRun needs pkgutil to also work for frozen modules,
+        # since pkgutil is used by the runpy module, which is needed
+        # to implement the -m command line switch.
+        if self.code is not None:
+            return self.code
         fullname = self._fix_name(fullname)
-        if self.code is None:
-            mod_type = self.etc[2]
-            if mod_type==imp.PY_SOURCE:
-                source = self.get_source(fullname)
-                self.code = compile(source, self.filename, 'exec')
-            elif mod_type==imp.PY_COMPILED:
-                self._reopen()
-                try:
-                    self.code = read_code(self.file)
-                finally:
-                    self.file.close()
-            elif mod_type==imp.PKG_DIRECTORY:
-                self.code = self._get_delegate().get_code()
+        mod_type = self.etc[2]
+        if mod_type == imp.PY_FROZEN:
+            self.code = imp.get_frozen_object(fullname)
+            return self.code
+        elif mod_type==imp.PY_SOURCE:
+            source = self.get_source(fullname)
+            self.code = compile(source, self.filename, 'exec')
+        elif mod_type==imp.PY_COMPILED:
+            self._reopen()
+            try:
+                self.code = read_code(self.file)
+            finally:
+                self.file.close()
+        elif mod_type==imp.PKG_DIRECTORY:
+            self.code = self._get_delegate().get_code()
         return self.code
 
     def get_source(self, fullname=None):
diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Modules/_ctypes/libffi/src/x86/ffi.c ./Modules/_ctypes/libffi/src/x86/ffi.c
--- /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Modules/_ctypes/libffi/src/x86/ffi.c	2014-12-10 16:59:52.000000000 +0100
+++ ./Modules/_ctypes/libffi/src/x86/ffi.c	2015-05-07 12:57:08.099883964 +0200
@@ -331,10 +331,11 @@
 extern int
 ffi_call_win64(void (*)(char *, extended_cif *), extended_cif *,
                unsigned, unsigned, unsigned *, void (*fn)(void));
-#else
+#elif defined(X86_WIN32)
 extern void
 ffi_call_win32(void (*)(char *, extended_cif *), extended_cif *,
                unsigned, unsigned, unsigned, unsigned *, void (*fn)(void));
+#else
 extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,
                           unsigned, unsigned, unsigned *, void (*fn)(void));
 #endif
@@ -376,16 +377,9 @@
       ffi_call_win64(ffi_prep_args, &ecif, cif->bytes,
                      cif->flags, ecif.rvalue, fn);
       break;
-#else
-#ifndef X86_WIN32
-    case FFI_SYSV:
-      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,
-                    fn);
-      break;
-#else
+#elif defined(X86_WIN32)
     case FFI_SYSV:
     case FFI_MS_CDECL:
-#endif
     case FFI_STDCALL:
       ffi_call_win32(ffi_prep_args, &ecif, cif->abi, cif->bytes, cif->flags,
 		     ecif.rvalue, fn);
@@ -419,6 +413,11 @@
                        ecif.rvalue, fn);
       }
       break;
+#else
+    case FFI_SYSV:
+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,
+                    fn);
+      break;
 #endif
     default:
       FFI_ASSERT(0);
@@ -787,28 +786,36 @@
   /* If the return value is a struct and we don't have a return */
   /* value address then we need to make one                     */
 
+#ifdef X86_WIN64
+  if (rvalue == NULL
+      && cif->flags == FFI_TYPE_STRUCT
+      && cif->rtype->size != 1 && cif->rtype->size != 2
+      && cif->rtype->size != 4 && cif->rtype->size != 8)
+    {
+      ecif.rvalue = alloca((cif->rtype->size + 0xF) & ~0xF);
+    }
+#else
   if (rvalue == NULL
       && (cif->flags == FFI_TYPE_STRUCT
           || cif->flags == FFI_TYPE_MS_STRUCT))
     {
       ecif.rvalue = alloca(cif->rtype->size);
     }
+#endif
   else
     ecif.rvalue = rvalue;
     
   
   switch (cif->abi) 
     {
-#ifndef X86_WIN32
-    case FFI_SYSV:
-      ffi_call_SYSV(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,
-                    ecif.rvalue, fn);
+#ifdef X86_WIN64
+    case FFI_WIN64:
+      ffi_call_win64(ffi_prep_args_raw, &ecif, cif->bytes,
+                     cif->flags, ecif.rvalue, fn);
       break;
-#else
+#elif defined(X86_WIN32)
     case FFI_SYSV:
     case FFI_MS_CDECL:
-#endif
-#ifndef X86_WIN64
     case FFI_STDCALL:
       ffi_call_win32(ffi_prep_args_raw, &ecif, cif->abi, cif->bytes, cif->flags,
 		     ecif.rvalue, fn);
@@ -835,13 +842,18 @@
 	    ++passed_regs;
 	  }
 	if (passed_regs < 2 && abi == FFI_FASTCALL)
-	  cif->abi = abi = FFI_THISCALL;
+	  abi = FFI_THISCALL;
 	if (passed_regs < 1 && abi == FFI_THISCALL)
-	  cif->abi = abi = FFI_STDCALL;
+	  abi = FFI_STDCALL;
         ffi_call_win32(ffi_prep_args_raw, &ecif, abi, cif->bytes, cif->flags,
                        ecif.rvalue, fn);
       }
       break;
+#else
+    case FFI_SYSV:
+      ffi_call_SYSV(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags, ecif.rvalue,
+                    fn);
+      break;
 #endif
     default:
       FFI_ASSERT(0);
diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Modules/getpath.c ./Modules/getpath.c
--- /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Modules/getpath.c	2014-12-10 16:59:55.000000000 +0100
+++ ./Modules/getpath.c	2015-04-21 15:44:02.530714258 +0200
@@ -465,6 +465,17 @@
         strncpy(argv0_path, progpath, MAXPATHLEN);
         argv0_path[MAXPATHLEN] = '\0';
 
+    /* For PyRun we don't need all the machinery to setup sys.path, since
+       we're doing that in pyrun.py, so just use some sane defaults and
+       return. */
+    if (Py_FrozenFlag) {
+        strncpy(prefix, PREFIX, MAXPATHLEN);
+        strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
+        module_search_path = (char *)PyMem_Malloc(MAXPATHLEN + 1);
+        strncpy(module_search_path, PREFIX "/lib/python" VERSION, MAXPATHLEN);
+        return;
+    }
+
 #ifdef WITH_NEXT_FRAMEWORK
         /* On Mac OS X we have a special case if we're running from a framework.
         ** This is because the python home should be set relative to the library,
diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Python/import.c ./Python/import.c
--- /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Python/import.c	2014-12-10 16:59:59.000000000 +0100
+++ ./Python/import.c	2015-04-21 15:44:02.530714258 +0200
@@ -2102,7 +2102,7 @@
         if (err != 0)
             goto err_return;
     }
-    m = PyImport_ExecCodeModuleEx(name, co, "<frozen>");
+    m = PyImport_ExecCodeModule(name, co);
     if (m == NULL)
         goto err_return;
     Py_DECREF(co);
diff -ur -x importlib.h /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Python/sysmodule.c ./Python/sysmodule.c
--- /home/lemburg/egenix/projects/PyRun/Python-2.7.9/Python/sysmodule.c	2014-12-10 16:59:59.000000000 +0100
+++ ./Python/sysmodule.c	2015-04-21 15:44:02.530714258 +0200
@@ -916,6 +916,49 @@
 Clear the internal type lookup cache.");
 
 
+/*** PyRun Extension ***************************************************/
+
+#define SYS_SETFLAG(c_flag, flag_name)		\
+    if (strcmp(flagname, flag_name) == 0) {	\
+	old_value = c_flag;			\
+	if (value != -1)			\
+	    c_flag = value;			\
+    } else
+
+static PyObject *
+sys_setflag(PyObject* self, PyObject* args)
+{
+    char *flagname;
+    int value = -1, old_value = value;
+
+    if (!PyArg_ParseTuple(args, "s|i", &flagname, &value))
+        goto onError;
+
+    SYS_SETFLAG(Py_DebugFlag, "debug")
+    SYS_SETFLAG(Py_OptimizeFlag, "optimize")
+    SYS_SETFLAG(Py_DontWriteBytecodeFlag, "dont_write_bytecode")
+    SYS_SETFLAG(Py_VerboseFlag, "verbose")
+    SYS_SETFLAG(Py_HashRandomizationFlag, "hash_randomization")
+    {
+        PyErr_SetString(PyExc_ValueError,
+                        "unknown flag name");
+	goto onError;
+    }
+    return PyInt_FromLong((long)old_value);
+
+ onError:
+    return NULL;
+}
+
+#undef SYS_SETFLAG
+
+PyDoc_STRVAR(sys_setflag__doc__,
+"_setflag(flagname, value) -> old_value\n\
+Set the given interpreter flag and return its previous value.");
+
+/*** End of PyRun Extension ***********************************************/
+
+
 static PyMethodDef sys_methods[] = {
     /* Might as well keep this in alphabetic order */
     {"callstats", (PyCFunction)PyEval_GetCallStats, METH_NOARGS,
@@ -978,6 +1021,7 @@
     {"setdlopenflags", sys_setdlopenflags, METH_VARARGS,
      setdlopenflags_doc},
 #endif
+    {"_setflag", sys_setflag, METH_VARARGS, sys_setflag__doc__},
     {"setprofile",      sys_setprofile, METH_O, setprofile_doc},
     {"getprofile",      sys_getprofile, METH_NOARGS, getprofile_doc},
     {"setrecursionlimit", sys_setrecursionlimit, METH_VARARGS,
