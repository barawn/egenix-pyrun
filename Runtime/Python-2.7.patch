--- Modules/getpath.c.orig	2012-04-23 00:02:04.266427614 +0200
+++ Modules/getpath.c	2012-04-23 00:40:49.654193120 +0200
@@ -448,10 +448,21 @@ calculate_path(void)
         if (progpath[0] != SEP && progpath[0] != '\0')
                 absolutize(progpath);
         strncpy(argv0_path, progpath, MAXPATHLEN);
         argv0_path[MAXPATHLEN] = '\0';
 
+    /* For PyRun we don't need all the machinery to setup sys.path, since
+       we're doing that in pyrun.py, so just use some sane defaults and
+       return. */
+    if (Py_FrozenFlag) {
+	strncpy(prefix, PREFIX, MAXPATHLEN);
+	strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
+	module_search_path = (char *)PyMem_Malloc(MAXPATHLEN);
+	strncpy(module_search_path, PREFIX "/lib/python" VERSION, MAXPATHLEN);
+	return;
+    }
+
 #ifdef WITH_NEXT_FRAMEWORK
         /* On Mac OS X we have a special case if we're running from a framework.
         ** This is because the python home should be set relative to the library,
         ** which is in the framework, not relative to the executable, which may
         ** be outside of the framework. Except when we're in the build directory...
--- Python-2.7.4/Python/sysmodule.c	2013-04-06 16:02:40.000000000 +0200
+++ Python/sysmodule.c	2013-04-23 19:38:24.929313095 +0200
@@ -897,10 +897,53 @@ sys_clear_type_cache(PyObject* self, PyO
 PyDoc_STRVAR(sys_clear_type_cache__doc__,
 "_clear_type_cache() -> None\n\
 Clear the internal type lookup cache.");
 
 
+/*** PyRun Extension ***************************************************/
+
+#define SYS_SETFLAG(c_flag, flag_name)		\
+    if (strcmp(flagname, flag_name) == 0) {	\
+	old_value = c_flag;			\
+	if (value != -1)			\
+	    c_flag = value;			\
+    } else
+
+static PyObject *
+sys_setflag(PyObject* self, PyObject* args)
+{
+    char *flagname;
+    int value = -1, old_value = value;
+
+    if (!PyArg_ParseTuple(args, "s|i", &flagname, &value))
+        goto onError;
+
+    SYS_SETFLAG(Py_DebugFlag, "debug")
+    SYS_SETFLAG(Py_OptimizeFlag, "optimize")
+    SYS_SETFLAG(Py_DontWriteBytecodeFlag, "dont_write_bytecode")
+    SYS_SETFLAG(Py_VerboseFlag, "verbose")
+    SYS_SETFLAG(Py_HashRandomizationFlag, "hash_randomization")
+    {
+        PyErr_SetString(PyExc_ValueError,
+                        "unknown flag name");
+	goto onError;
+    }
+    return PyInt_FromLong((long)old_value);
+
+ onError:
+    return NULL;
+}
+
+#undef SYS_SETFLAG
+
+PyDoc_STRVAR(sys_setflag__doc__,
+"_setflag(flagname, value) -> old_value\n\
+Set the given interpreter flag and return its previous value.");
+
+/*** End of PyRun Extension ***********************************************/
+
+
 static PyMethodDef sys_methods[] = {
     /* Might as well keep this in alphabetic order */
     {"callstats", (PyCFunction)PyEval_GetCallStats, METH_NOARGS,
      callstats_doc},
     {"_clear_type_cache",       sys_clear_type_cache,     METH_NOARGS,
@@ -959,10 +1002,11 @@ static PyMethodDef sys_methods[] = {
      getcheckinterval_doc},
 #ifdef HAVE_DLOPEN
     {"setdlopenflags", sys_setdlopenflags, METH_VARARGS,
      setdlopenflags_doc},
 #endif
+    {"_setflag", sys_setflag, METH_VARARGS, sys_setflag__doc__},
     {"setprofile",      sys_setprofile, METH_O, setprofile_doc},
     {"getprofile",      sys_getprofile, METH_NOARGS, getprofile_doc},
     {"setrecursionlimit", sys_setrecursionlimit, METH_VARARGS,
      setrecursionlimit_doc},
 #ifdef WITH_TSC
diff -u -U 5 -p -ur /home/lemburg/orig/Python-2.7.4/Modules/_sqlite/cursor.c Modules/_sqlite/cursor.c
--- /home/lemburg/orig/Python-2.7.4/Modules/_sqlite/cursor.c	2013-04-06 16:02:36.000000000 +0200
+++ Modules/_sqlite/cursor.c	2013-04-27 23:11:53.199461926 +0200
@@ -730,11 +730,11 @@ PyObject* _pysqlite_query_execute(pysqli
                 self->rowcount += (long)sqlite3_changes(self->connection->db);
         }
 
         Py_DECREF(self->lastrowid);
         if (!multiple && statement_type == STATEMENT_INSERT) {
-            sqlite3_int64 lastrowid;
+            sqlite_int64 lastrowid;
             Py_BEGIN_ALLOW_THREADS
             lastrowid = sqlite3_last_insert_rowid(self->connection->db);
             Py_END_ALLOW_THREADS
             self->lastrowid = _pysqlite_long_from_int64(lastrowid);
         } else {
Only in Modules/_sqlite: cursor.c.bak
diff -u -U 5 -p -ur /home/lemburg/orig/Python-2.7.4/Modules/_sqlite/util.c Modules/_sqlite/util.c
--- /home/lemburg/orig/Python-2.7.4/Modules/_sqlite/util.c	2013-04-06 16:02:36.000000000 +0200
+++ Modules/_sqlite/util.c	2013-04-27 23:11:53.234458963 +0200
@@ -109,11 +109,11 @@ int _pysqlite_seterror(sqlite3* db, sqli
 #else
 # define IS_LITTLE_ENDIAN 1
 #endif
 
 PyObject *
-_pysqlite_long_from_int64(sqlite3_int64 value)
+_pysqlite_long_from_int64(sqlite_int64 value)
 {
 #ifdef HAVE_LONG_LONG
 # if SIZEOF_LONG_LONG < 8
     if (value > PY_LLONG_MAX || value < PY_LLONG_MIN) {
         return _PyLong_FromByteArray(&value, sizeof(value),
@@ -133,11 +133,11 @@ _pysqlite_long_from_int64(sqlite3_int64
 # endif
 #endif
     return PyInt_FromLong(value);
 }
 
-sqlite3_int64
+sqlite_int64
 _pysqlite_long_as_int64(PyObject * py_val)
 {
     int overflow;
 #ifdef HAVE_LONG_LONG
     PY_LONG_LONG value = PyLong_AsLongLongAndOverflow(py_val, &overflow);
@@ -156,12 +156,12 @@ _pysqlite_long_as_int64(PyObject * py_va
         if (-0x8000000000000000L <= value && value <= 0x7FFFFFFFFFFFFFFFL)
 # endif
 #endif
             return value;
     }
-    else if (sizeof(value) < sizeof(sqlite3_int64)) {
-        sqlite3_int64 int64val;
+    else if (sizeof(value) < sizeof(sqlite_int64)) {
+        sqlite_int64 int64val;
         if (_PyLong_AsByteArray((PyLongObject *)py_val,
                                 (unsigned char *)&int64val, sizeof(int64val),
                                 IS_LITTLE_ENDIAN, 1 /* signed */) >= 0) {
             return int64val;
         }
Only in Modules/_sqlite: util.c.bak
diff -u -U 5 -p -ur /home/lemburg/orig/Python-2.7.4/Modules/_sqlite/util.h Modules/_sqlite/util.h
--- /home/lemburg/orig/Python-2.7.4/Modules/_sqlite/util.h	2013-04-06 16:02:36.000000000 +0200
+++ Modules/_sqlite/util.h	2013-04-27 20:54:41.299329457 +0200
@@ -34,9 +34,9 @@ int pysqlite_step(sqlite3_stmt* statemen
  * Checks the SQLite error code and sets the appropriate DB-API exception.
  * Returns the error code (0 means no error occurred).
  */
 int _pysqlite_seterror(sqlite3* db, sqlite3_stmt* st);
 
-PyObject * _pysqlite_long_from_int64(sqlite3_int64 value);
-sqlite3_int64 _pysqlite_long_as_int64(PyObject * value);
+PyObject * _pysqlite_long_from_int64(sqlite_int64 value);
+sqlite_int64 _pysqlite_long_as_int64(PyObject * value);
 
 #endif
