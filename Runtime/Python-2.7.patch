--- Modules/getpath.c.orig	2012-04-23 00:02:04.266427614 +0200
+++ Modules/getpath.c	2012-04-23 00:40:49.654193120 +0200
@@ -448,10 +448,21 @@ calculate_path(void)
         if (progpath[0] != SEP && progpath[0] != '\0')
                 absolutize(progpath);
         strncpy(argv0_path, progpath, MAXPATHLEN);
         argv0_path[MAXPATHLEN] = '\0';
 
+    /* For PyRun we don't need all the machinery to setup sys.path, since
+       we're doing that in pyrun.py, so just use some sane defaults and
+       return. */
+    if (Py_FrozenFlag) {
+	strncpy(prefix, PREFIX, MAXPATHLEN);
+	strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
+	module_search_path = (char *)PyMem_Malloc(MAXPATHLEN);
+	strncpy(module_search_path, PREFIX "/lib/python" VERSION, MAXPATHLEN);
+	return;
+    }
+
 #ifdef WITH_NEXT_FRAMEWORK
         /* On Mac OS X we have a special case if we're running from a framework.
         ** This is because the python home should be set relative to the library,
         ** which is in the framework, not relative to the executable, which may
         ** be outside of the framework. Except when we're in the build directory...
--- Modules/_sqlite/connection.c~       2012-04-10 01:07:33.000000000 +0200
+++ Modules/_sqlite/connection.c        2012-05-04 12:34:04.890776045 +0200
@@ -547,11 +547,11 @@ void _pysqlite_set_result(sqlite3_contex
     if ((!py_val) || PyErr_Occurred()) {
         sqlite3_result_null(context);
     } else if (py_val == Py_None) {
         sqlite3_result_null(context);
     } else if (PyInt_Check(py_val)) {
-        sqlite3_result_int64(context, (sqlite3_int64)PyInt_AsLong(py_val));
+        sqlite3_result_int64(context, (sqlite_int64)PyInt_AsLong(py_val));
     } else if (PyLong_Check(py_val)) {
         sqlite3_result_int64(context, PyLong_AsLongLong(py_val));
     } else if (PyFloat_Check(py_val)) {
         sqlite3_result_double(context, PyFloat_AsDouble(py_val));
     } else if (PyBuffer_Check(py_val)) {
@@ -578,11 +578,11 @@ PyObject* _pysqlite_build_py_params(sqli
     PyObject* args;
     int i;
     sqlite3_value* cur_value;
     PyObject* cur_py_value;
     const char* val_str;
-    sqlite3_int64 val_int;
+    sqlite_int64 val_int;
     Py_ssize_t buflen;
     void* raw_buffer;

     args = PyTuple_New(argc);
     if (!args) {
--- Python/import.c.orig	2012-04-10 01:07:35.000000000 +0200
+++ Python/import.c	2012-09-24 20:49:22.050398007 +0200
@@ -1259,49 +1259,30 @@ find_module(char *fullname, char *subnam
             Py_DECREF(loader);
         }
         Py_DECREF(meta_path);
     }
 
-    if (path != NULL && PyString_Check(path)) {
-        /* The only type of submodule allowed inside a "frozen"
-           package are other frozen modules or packages. */
-        if (PyString_Size(path) + 1 + strlen(name) >= (size_t)buflen) {
-            PyErr_SetString(PyExc_ImportError,
-                            "full frozen module name too long");
-            return NULL;
-        }
-        strcpy(buf, PyString_AsString(path));
-        strcat(buf, ".");
-        strcat(buf, name);
-        strcpy(name, buf);
-        if (find_frozen(name) != NULL) {
-            strcpy(buf, name);
-            return &fd_frozen;
-        }
-        PyErr_Format(PyExc_ImportError,
-                     "No frozen submodule named %.200s", name);
-        return NULL;
+    if (find_frozen(fullname) != NULL) {
+	strcpy(buf, fullname);
+	return &fd_frozen;
     }
+
     if (path == NULL) {
         if (is_builtin(name)) {
             strcpy(buf, name);
             return &fd_builtin;
         }
-        if ((find_frozen(name)) != NULL) {
-            strcpy(buf, name);
-            return &fd_frozen;
-        }
-
 #ifdef MS_COREDLL
         fp = PyWin_FindRegisteredModule(name, &fdp, buf, buflen);
         if (fp != NULL) {
             *p_fp = fp;
             return fdp;
         }
 #endif
         path = PySys_GetObject("path");
     }
+
     if (path == NULL || !PyList_Check(path)) {
         PyErr_SetString(PyExc_RuntimeError,
                         "sys.path must be a list of directory names");
         return NULL;
     }
@@ -1929,10 +1910,13 @@ init_builtin(char *name)
 static struct _frozen *
 find_frozen(char *name)
 {
     struct _frozen *p;
 
+    if (!name)
+        return NULL;
+
     for (p = PyImport_FrozenModules; ; p++) {
         if (p->name == NULL)
             return NULL;
         if (strcmp(p->name, name) == 0)
             break;
@@ -2002,21 +1986,27 @@ PyImport_ImportFrozenModule(char *name)
                      name);
         goto err_return;
     }
     if (ispackage) {
         /* Set __path__ to the package name */
-        PyObject *d, *s;
+        PyObject *d, *s, *l;
         int err;
         m = PyImport_AddModule(name);
         if (m == NULL)
             goto err_return;
         d = PyModule_GetDict(m);
         s = PyString_InternFromString(name);
         if (s == NULL)
             goto err_return;
-        err = PyDict_SetItemString(d, "__path__", s);
-        Py_DECREF(s);
+	l = PyList_New(1);
+	if (l == NULL) {
+	    Py_DECREF(s);
+	    goto err_return;
+	}
+	PyList_SET_ITEM(l, 0, s);
+	err = PyDict_SetItemString(d, "__path__", l);
+	Py_DECREF(l);
         if (err != 0)
             goto err_return;
     }
     m = PyImport_ExecCodeModuleEx(name, co, "<frozen>");
     if (m == NULL)
