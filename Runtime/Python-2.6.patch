--- Modules/getpath.c.orig	2010-07-24 12:09:36.000000000 +0200
+++ Modules/getpath.c	2012-04-23 01:00:43.650066507 +0200
@@ -444,10 +444,21 @@ calculate_path(void)
         if (progpath[0] != SEP && progpath[0] != '\0')
                 absolutize(progpath);
         strncpy(argv0_path, progpath, MAXPATHLEN);
         argv0_path[MAXPATHLEN] = '\0';
 
+    /* For PyRun we don't need all the machinery to setup sys.path, since
+       we're doing that in pyrun.py, so just use some sane defaults and
+       return. */
+    if (Py_FrozenFlag) {
+	strncpy(prefix, PREFIX, MAXPATHLEN);
+	strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
+	module_search_path = (char *)PyMem_Malloc(MAXPATHLEN);
+	strncpy(module_search_path, PREFIX "/lib/python" VERSION, MAXPATHLEN);
+	return;
+    }
+
 #ifdef WITH_NEXT_FRAMEWORK
         /* On Mac OS X we have a special case if we're running from a framework.
         ** This is because the python home should be set relative to the library,
         ** which is in the framework, not relative to the executable, which may
         ** be outside of the framework. Except when we're in the build directory...
--- Python/import.c.orig	2010-05-20 20:41:08.000000000 +0200
+++ Python/import.c	2012-09-24 20:52:31.817377471 +0200
@@ -1258,40 +1258,20 @@ find_module(char *fullname, char *subnam
             Py_DECREF(loader);
         }
         Py_DECREF(meta_path);
     }
 
-    if (path != NULL && PyString_Check(path)) {
-        /* The only type of submodule allowed inside a "frozen"
-           package are other frozen modules or packages. */
-        if (PyString_Size(path) + 1 + strlen(name) >= (size_t)buflen) {
-            PyErr_SetString(PyExc_ImportError,
-                            "full frozen module name too long");
-            return NULL;
-        }
-        strcpy(buf, PyString_AsString(path));
-        strcat(buf, ".");
-        strcat(buf, name);
-        strcpy(name, buf);
-        if (find_frozen(name) != NULL) {
-            strcpy(buf, name);
-            return &fd_frozen;
-        }
-        PyErr_Format(PyExc_ImportError,
-                     "No frozen submodule named %.200s", name);
-        return NULL;
+    if (find_frozen(fullname) != NULL) {
+	strcpy(buf, fullname);
+	return &fd_frozen;
     }
+
     if (path == NULL) {
         if (is_builtin(name)) {
             strcpy(buf, name);
             return &fd_builtin;
         }
-        if ((find_frozen(name)) != NULL) {
-            strcpy(buf, name);
-            return &fd_frozen;
-        }
-
 #ifdef MS_COREDLL
         fp = PyWin_FindRegisteredModule(name, &fdp, buf, buflen);
         if (fp != NULL) {
             *p_fp = fp;
             return fdp;
@@ -1928,10 +1908,13 @@ init_builtin(char *name)
 static struct _frozen *
 find_frozen(char *name)
 {
     struct _frozen *p;
 
+    if (!name)
+        return NULL;
+
     for (p = PyImport_FrozenModules; ; p++) {
         if (p->name == NULL)
             return NULL;
         if (strcmp(p->name, name) == 0)
             break;
@@ -2001,21 +1984,27 @@ PyImport_ImportFrozenModule(char *name)
                      name);
         goto err_return;
     }
     if (ispackage) {
         /* Set __path__ to the package name */
-        PyObject *d, *s;
+        PyObject *d, *s, *l;
         int err;
         m = PyImport_AddModule(name);
         if (m == NULL)
             goto err_return;
         d = PyModule_GetDict(m);
         s = PyString_InternFromString(name);
         if (s == NULL)
             goto err_return;
-        err = PyDict_SetItemString(d, "__path__", s);
-        Py_DECREF(s);
+	l = PyList_New(1);
+	if (l == NULL) {
+	    Py_DECREF(s);
+	    goto err_return;
+	}
+	PyList_SET_ITEM(l, 0, s);
+	err = PyDict_SetItemString(d, "__path__", l);
+	Py_DECREF(l);
         if (err != 0)
             goto err_return;
     }
     m = PyImport_ExecCodeModuleEx(name, co, "<frozen>");
     if (m == NULL)
