diff -ur /home/lemburg/egenix/projects/PyRun/Python-2.6.9/Modules/getpath.c ./Modules/getpath.c
--- /home/lemburg/egenix/projects/PyRun/Python-2.6.9/Modules/getpath.c	2013-10-29 16:04:38.000000000 +0100
+++ ./Modules/getpath.c	2014-06-11 17:17:56.283185279 +0200
@@ -446,6 +446,17 @@
         strncpy(argv0_path, progpath, MAXPATHLEN);
         argv0_path[MAXPATHLEN] = '\0';
 
+    /* For PyRun we don't need all the machinery to setup sys.path, since
+       we're doing that in pyrun.py, so just use some sane defaults and
+       return. */
+    if (Py_FrozenFlag) {
+	strncpy(prefix, PREFIX, MAXPATHLEN);
+	strncpy(exec_prefix, EXEC_PREFIX, MAXPATHLEN);
+	module_search_path = (char *)PyMem_Malloc(MAXPATHLEN + 1);
+	strncpy(module_search_path, PREFIX "/lib/python" VERSION, MAXPATHLEN);
+	return;
+    }
+
 #ifdef WITH_NEXT_FRAMEWORK
         /* On Mac OS X we have a special case if we're running from a framework.
         ** This is because the python home should be set relative to the library,
diff -ur /home/lemburg/egenix/projects/PyRun/Python-2.6.9/Python/import.c ./Python/import.c
--- /home/lemburg/egenix/projects/PyRun/Python-2.6.9/Python/import.c	2013-10-29 16:04:39.000000000 +0100
+++ ./Python/import.c	2014-06-11 17:16:23.262358742 +0200
@@ -2017,7 +2017,7 @@
         if (err != 0)
             goto err_return;
     }
-    m = PyImport_ExecCodeModuleEx(name, co, "<frozen>");
+    m = PyImport_ExecCodeModule(name, co);
     if (m == NULL)
         goto err_return;
     Py_DECREF(co);
diff -ur /home/lemburg/egenix/projects/PyRun/Python-2.6.9/Python/sysmodule.c ./Python/sysmodule.c
--- /home/lemburg/egenix/projects/PyRun/Python-2.6.9/Python/sysmodule.c	2013-10-29 16:04:39.000000000 +0100
+++ ./Python/sysmodule.c	2013-12-05 18:47:41.059022637 +0100
@@ -860,6 +860,48 @@
 Clear the internal type lookup cache.");
 
 
+/*** PyRun Extension ***************************************************/
+
+#define SYS_SETFLAG(c_flag, flag_name)		\
+    if (strcmp(flagname, flag_name) == 0) {	\
+	old_value = c_flag;			\
+	if (value != -1)			\
+	    c_flag = value;			\
+    } else
+
+static PyObject *
+sys_setflag(PyObject* self, PyObject* args)
+{
+    char *flagname;
+    int value = -1, old_value = value;
+
+    if (!PyArg_ParseTuple(args, "s|i", &flagname, &value))
+        goto onError;
+
+    SYS_SETFLAG(Py_DebugFlag, "debug")
+    SYS_SETFLAG(Py_OptimizeFlag, "optimize")
+    SYS_SETFLAG(Py_DontWriteBytecodeFlag, "dont_write_bytecode")
+    SYS_SETFLAG(Py_VerboseFlag, "verbose")
+    {
+        PyErr_SetString(PyExc_ValueError,
+                        "unknown flag name");
+	goto onError;
+    }
+    return PyInt_FromLong((long)old_value);
+
+ onError:
+    return NULL;
+}
+
+#undef SYS_SETFLAG
+
+PyDoc_STRVAR(sys_setflag__doc__,
+"_setflag(flagname, value) -> old_value\n\
+Set the given interpreter flag and return its previous value.");
+
+/*** End of PyRun Extension ***********************************************/
+
+
 static PyMethodDef sys_methods[] = {
     /* Might as well keep this in alphabetic order */
     {"callstats", (PyCFunction)PyEval_GetCallStats, METH_NOARGS,
@@ -922,6 +964,7 @@
     {"setdlopenflags", sys_setdlopenflags, METH_VARARGS,
      setdlopenflags_doc},
 #endif
+    {"_setflag", sys_setflag, METH_VARARGS, sys_setflag__doc__},
     {"setprofile",      sys_setprofile, METH_O, setprofile_doc},
     {"getprofile",      sys_getprofile, METH_NOARGS, getprofile_doc},
     {"setrecursionlimit", sys_setrecursionlimit, METH_VARARGS,
